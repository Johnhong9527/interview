{"./":{"url":"./","title":"关于本文档","keywords":"","body":"说明 本文档分为上下2部分内容基础和进阶;这2部分内容会进一步随内容的深入而展开.基本就这些了 "},"JavaScript/principle/":{"url":"JavaScript/principle/","title":"原理解析","keywords":"","body":"原理解析 "},"JavaScript/principle/0_data_type.html":{"url":"JavaScript/principle/0_data_type.html","title":"数据类型","keywords":"","body":"数据类型 window.onload = () => { var test1 = \"abcdef\"; var test2 = 123; var test3 = true; var test4 = {}; var test5 = []; var test6; var test7 = { \"abcdef\": 123 }; var test8 = [\"abcdef\", 123]; function test9() { return \"abcdef\" }; var test10 = null; var test11 = 'q58'; var test12 = '张'; var test13 = '78'; console.log(typeof test1); // string console.log(typeof test2); // number console.log(typeof test3); // boolean console.log(typeof test4); // object console.log(typeof test5); // object console.log(typeof test6); // undefined console.log(typeof test7); // object console.log(typeof test8); // object console.log(typeof test9); // function console.log(typeof test10); // object // # 无法转为数字的为true console.log(isNaN(test11)); // true console.log(isNaN(test12)); // true console.log(isNaN(test13)); // false // 数值比较 console.log(\"1\" - \"1\"); // 5个假值：undefined null “” 0 NaN // ** 字符串方法 ** // toLowerCase() 字符串大写 =>小写 // toUpperCase() 字符串小写 => 大写 // replace() 查找子串并将他们都替换为另一个字符串 // slice() 删除字符串的一部分并返回结果 // indexOf() 从头部开始查找子串,返回下标 // lastIndexOf() 查找最后一个子串,返回下标 // concat() 将字符串拼接起来 // match() 在字符串中查找与正则表达啥匹配的子串 // trim() 删除字符串开头和末尾的的空白字符, let phone = \"123-8568\"; function phoneF(number) { return number.match(/^\\d{3}-?\\d{4}$/); } console.log(phoneF(phone)); // 实例化对象 function Duck(sound) { this.sound = sound; this.quack = () => { console.log(this.sound) } } let toy = new Duck('quack quack'); toy.quack(); console.log(typeof toy); // object console.log(toy instanceof Duck); // true } "},"JavaScript/principle/001_object.html":{"url":"JavaScript/principle/001_object.html","title":"Object","keywords":"","body":"Object 判断 obj 对象 参考文章:判断 JS 数据类型的 4 种方法 typeof /* typeof 是一个操作符，其右侧跟一个一元表达式， 并返回这个表达式的数据类型。 返回的结果用该类型的字符串(全小写字母)形式表示， 包括以下 7 种： number、boolean、symbol、string、 object、undefined、function 等。 */ typeof ''; // string 有效 typeof 1; // number 有效 typeof Symbol(); // symbol 有效 typeof true; //boolean 有效 typeof undefined; //undefined 有效 typeof null; //object 无效 typeof [] ; //object 无效 typeof new Function(); // function 有效 typeof new Date(); //object 无效 typeof new RegExp(); //object 无效 /* 其他正确,但不符合判断的结果 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。 */ instanceof instanceof认为能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例 why? 从 instanceof 能够判断出 [ ].proto 指向 Array.prototype，而 Array.prototype.proto 又指向了Object.prototype，最终 Object.prototype.proto 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链： // 内部执行过程 function instanceof (A,B) = { var L = A.__proto__; var R = B.prototype; if(L === R) { // A的内部属性 __proto__ 指向 B 的原型对象 return true; } return false; } constructor使用技巧 toString Object.prototype.toString.call('') ; // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true) ; // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined) ; // [object Undefined] Object.prototype.toString.call(null) ; // [object Null] Object.prototype.toString.call(new Function()) ; // [object Function] Object.prototype.toString.call(new Date()) ; // [object Date] Object.prototype.toString.call([]) ; // [object Array] Object.prototype.toString.call(new RegExp()) ; // [object RegExp] Object.prototype.toString.call(new Error()) ; // [object Error] Object.prototype.toString.call(document) ; // [object HTMLDocument] Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 代码风格 let time = { a: function(a) { console.log(a); }, b: function(b) { console.log(\"b:\" + b); }, }; time.b(385); es6 常见代码片段 // 获取对象的key Object.keys({ name: \"seamong\", age: 1 }); // 获取对象里数据的数量 Object.keys({ name: \"seamong\", age: 1 }).length; // 遍历数组 Object.entries({ name: \"seamong\", age: 1 }); // extend功能 const obj = { name: \"seamong\", age: 3 }; const newObj = { ...obj, job: \"IT\", age: 18 }; console.log(newObj); // 获取列表的头和尾 const [head, ...tail] = [1, 2, 3]; const [head, ...initial] = [1, 2, 3].reverse(); "},"JavaScript/principle/002_array.html":{"url":"JavaScript/principle/002_array.html","title":"Array","keywords":"","body":"Array 常见代码片段 // 判断数组 const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; const obj = { name: \"hello\", age: 1 }; // instanceof方法(推荐使用) console.log(arr instanceof Array); //true console.log(arr instanceof Object); //true,在数组的原型链上也能找到Object构造函数 console.log(obj instanceof Array); //false // constructor方法(不推荐:constructor方法可以被修改) const a = []; const b = {}; const c = /^[0-9]$/; console.log(a.constructor == Array); //true console.log(b.constructor == Array); //false console.log(c.constructor == Array); //false // 不推荐理由 const a = []; //作死将constructor属性改成了别的 a.contrtuctor = Object; console.log(a.constructor == Array); //false (哭脸) console.log(a.constructor == Object); //true (哭脸) console.log(a instanceof Array); //true (instanceof火眼金睛) // 用Object的toString方法 const a = [\"Hello\", \"Howard\"]; const b = { 0: \"Hello\", 1: \"Howard\" }; const c = \"Hello Howard\"; console.log(a.toString()); //\"Hello,Howard\" console.log(b.toString()); //\"[object Object]\" console.log(c.toString()); //\"Hello,Howard\" // 通过改变toString执行时的上下文判断是否为数组 // call | apply Object.prototype.toString.call(a); // [object Array] Object.prototype.toString.call(b); // [object Object] Object.prototype.toString.call(c); // [object String] // or Object.prototype.toString.apply(a); //\"[object Array]\" Object.prototype.toString.apply(b); //\"[object Object]\" Object.prototype.toString.apply(c); //\"[object String]\" // 合并上述过程为函数 const isArray = (something)=>{ return Object.prototype.toString.call(something) === '[object Array]'; } const a = []; const b = {}; isArray(a);//true isArray(b);//false // 用Array对象的isArray方法判断 const a = []; const b = {}; Array.isArray(a);//true Array.isArray(b);//false Object.prototype.toString = ()=>{ console.log('Hello Howard'); } const a = []; Array.isArray(a);//true // 兼容性写法 if (!Array.isArray) { Array.isArray = function(arg) { return Object.prototype.toString.call(arg) === '[object Array]'; }; } // jquery方法判断 // 待续 es6 常见代码片段 // 遍历数组 [1, 2, 3].forEach(function(value, index) { console.log(value); }); // 映射新数组 arr = [1, 2, 3].map(v => v * 2); // 所有元素是否通过测试 [1, 2, , 3, 4].every(v => v > 3); // 是否有元素通过测试 [1, 2, , 3, 4].some(v => v > 3); // 过滤数组 [1, 2, 3, 4, 5].filter(v => v > 3); // 查找符合条件的元素: arr = [{ name: \"dashing\", age: 18 }, { name: \"rmos\", age: 1 }]; // 查找索引 [1, 2, 3].indexOf(2); // 连接数组 arr1 = [1, 2, 3]; arr2 = [4, 5, 6]; [...arr1, ...arr2]; //数组去重 arr = [1, 2, 3, 4, 3, 2, 1]; [...new Set(arr)]; "},"JavaScript/principle/002_DOM.html":{"url":"JavaScript/principle/002_DOM.html","title":"DOM","keywords":"","body":"DOM "},"JavaScript/principle/01.html":{"url":"JavaScript/principle/01.html","title":"HTML DOM Document 对象","keywords":"","body":"HTML DOM Document 对象 给文档对象添加/移除事件句柄 let btnEnter = document.getElementById('btnEnter'); function btn(){ alert('单击事件,被触发'); } /* # addEventListener: 给文档对象添加事件句柄 # 语法: document.addEventListener(event,function,useCapture) # event: 必需。描述事件名称的字符串。 # function: 必需。描述了事件触发后执行的函数。 # useCapture: 可选: # true - 事件句柄在捕获阶段执行 # false- 默认。事件句柄在冒泡阶段执行 */ btnEnter.addEventListener('click',btn()) /*您可以通过函数名来引用外部函数：*/ document.addEventListener(\"click\", myFunction); function myFunction() { document.getElementById(\"demo\").innerHTML = \"Hello World\"; } /* # reamveEventListener: 移除文档中的事件句柄 # 语法: document.remaveEventListener(event,function,useCapture) # event: 必需。要移除的事件名称。 # function: 必需。指定要移除的函数。 # useCapture: 可选: # true - 事件句柄在捕获阶段移除 # false- 默认。事件句柄在冒泡阶段移除 */ // removeEventListener // 移除文档对象已添加的事件句柄 btnEnter.removeEventListener('click',btn()) 返回当前获取焦点元素 语法: doucment.activeElement.tagName 定义和使用: activeElement 属性返回文档中当前获得焦点的元素。 btnName let name = document.getElementById('name'); let btnName = document.getElementById('btnName'); let btns = document.getElementById('btns'); 用法一(获取子元素焦点事件名称): btnS.addEventListener('click',function () { console.log(document.activeElement.tagName) // 输出所有子元素的焦点事件名称 }) 用法二(元素本身的焦点事件名称): name.addEventListener('click',function(){ console.log(document.activeElement.tagName); }) 　添加class属性 // 添加class属性 pater1.setAttribute(\"class\", \"redtext\"); // 获取class属性 :只对 ID 有效，class无效 let href = document.getElementById('href'); console.log(href.getAttribute('href')); "},"JavaScript/principle/02.html":{"url":"JavaScript/principle/02.html","title":"闭包","keywords":"","body":"闭包 下面是一个简单的闭包 function foo(x) { var tmp = 3; function bar(y) { alert(x + y + (++tmp)); } bar(10); } foo(2) 概念 闭包就是能够读取其他函数内部变量的函数。也可以理解成：定义再一个函数内部的函数。 作用 理解函数内部与外部的桥梁 用途 1.可以读取函数内部的变量。 2.让这些变量始终保持在内存中。 实例+分析 简单来说 getNameFunc() 是一个闭包函数， 我们在 对象 Object 中，定义了它。 接着定义了 var that=this; 并且在 getNameFunc() 里面，return 一个匿名函数， return 返回 that.name 和 this.name; 这个时候发现 that.name; ==>\"My Object\"; 为什么这个时候 this.name 的值是 \"My Object\" 而不是\"The Window\"。 this.name 这个时候，表示的是内部对象 Object 中定义的 name 的值。 这个name的值，初始是 \"My Object\" ，但是在 Object.getNameFunc() 运行之后， this 就不在表示 Object ，而是指代全局了。 那么这样子的话.不论我们如何去定义 this.name 的值。 全局中，var name = \"The Window\"; 被定义了。 我们这个时候 去输出 this.name 的话.结果都是 \"The Window\"。 那么为什么在 Object.getNameFunc() 函数运作之后，this 就表示全局了呢？ getNameFunc();是一个闭包函数。当我们运行它的时候。它被赋予全局变量 它就被存入到内存中。 var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ var that=this; return function(){ return 'that:'+that.name+';this:'+this.name; }; } }; console.log(object.getNameFunc()());//that:My Object;this:The Window 从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。 "},"JavaScript/principle/03.html":{"url":"JavaScript/principle/03.html","title":"写给初级JS程序员的JavaScript闭包(译)","keywords":"","body":"写给初级JS程序员的JavaScript闭包(译) 原文链接 闭包不是魔术 这个页面解释了closures，以便程序员可以理解它们 - 使用有效的JavaScript代码。它不是用于古茹或功能程序员。 一旦核心概念被解构，闭包不难理解。然而，他们不可能通过阅读任何学术论文或面向学术的信息来了解他们！ 本文主要面向有主流语言编程经验的程序员，他们可以阅读以下JavaScript函数： function sayHello(name) { var text = 'Hello ' + name; var say = function() { console.log(text); } say(); } sayHello('Joe'); 闭包的实例 两句话摘要：     .它是一个可以引用其范围内的变量（在第一次声明时），被赋值给变量，作为参数传递给函数或作为函数结果返回的表达式。     .闭包是一个堆栈框架，当函数开始执行时被分配，并且在函数返回之后不被释放（就好像“堆栈框架”在堆上分配而不是堆栈！）。 以下代码返回对函数的引用： function sayHello2(name) { var text = 'Hello ' + name; // Local variable var say = function() { console.log(text); } return say; } var say2 = sayHello2('Bob'); say2(); // logs \"Hello Bob\" 大多数JavaScript程序员将会理解在上面的代码中如何将一个函数的引用返回给一个变量。如果你没有，那么你需要在你可以学习闭包。AC程序员会认为函数返回一个指向函数的指针，变量sayAlert和say2都是指向函数的指针。 在指向函数的C指针和对函数的JavaScript引用之间存在关键的区别。在JavaScript中，您可以将函数引用变量看作具有指向函数的指针 以及指向闭包的隐藏指针。 上面的代码有一个闭包，因为匿名函数function（）{alert（text）; } 在另一个函数中声明，在这个例子中为sayHello2（）。在JavaScript中，如果在另一个函数中使用function关键字，则要创建一个闭包。 在C和大多数其他常用语言函数返回后，所有的局部变量不再可访问，因为堆栈帧被销毁。 在JavaScript中，如果在另一个函数中声明一个函数，那么在从调用的函数返回后，局部变量仍然可以访问。这是上面演示的，因为我们调用函数say2（）; 之后我们从sayHello2（）返回。请注意，我们调用的代码引用变量text，它是函数sayHello2（）的局部变量。 function() { console.log(text); } // Output of say2.toString(); 看看输出say2.toString()，我们可以看到代码引用的变量text。匿名函数可以引用text保存值的值'Hello Bob'，因为局部变量sayHello2()保存在闭包中。 神奇的是，在JavaScript中，函数引用还具有对其创建的闭包的秘密引用 - 类似于如何委托是方法指针加上对对象的秘密引用。 更多例子 出于某种原因，当你阅读关于它们的闭包似乎真的很难理解，但当你看到一些例子，你可以点击他们的工作（它花了我一段时间）。我建议仔细阅读示例，直到你了解它们如何工作。如果你开始使用闭包没有完全了解它们如何工作，你很快就会创建一些非常古怪的错误！ 例3 此示例显示不复制局部变量 - 它们通过引用保留。它是一种像在外部函数退出时在内存中保留一个堆栈框架！ function say667() { // Local variable that ends up within closure var num = 42; var say = function() { console.log(num); } num++; return say; } var sayNumber = say667(); sayNumber(); // logs 43 例4 所有三个全局函数具有对同一闭包的公共引用，因为它们都在单个调用中声明setupSomeGlobals()。 var gLogNumber, gIncreaseNumber, gSetNumber; function setupSomeGlobals() { // Local variable that ends up within closure var num = 42; // Store some references to functions as global variables gLogNumber = function() { console.log(num); } gIncreaseNumber = function() { num++; } gSetNumber = function(x) { num = x; } } setupSomeGlobals(); gIncreaseNumber(); gLogNumber(); // 43 gSetNumber(5); gLogNumber(); // 5 var oldLog = gLogNumber; setupSomeGlobals(); gLogNumber(); // 42 oldLog() // 5 这三个函数具有对同一闭包的共享访问 - setupSomeGlobals()当定义三个函数时的局部变量。 注意，在上面的例子中，如果setupSomeGlobals()再次调用，则创建一个新的闭包（stack-frame！）。老gLogNumber，gIncreaseNumber，gSetNumber变量将覆盖新的具有新功能关闭。（在JavaScript中，当你声明另一个函数内的函数，里面的功能（s）是/再次重新创建每个外部函数被调用时）。 例5 这是一个真正的困扰，许多人，所以你需要了解它。要非常小心，如果你在一个循环中定义一个函数：从闭包的局部变量不会像你可能会想的那样。 function buildList(list) { var result = []; for (var i = 0; i line result.push（function（）{console.log（item +''+ list [i]）}在结果数组中添加一个对匿名函数的引用三次。如果你不熟悉匿名函数， 就如： pointer = function() {console.log(item + ' ' + list[i])}; result.push(pointer); 注意，当运行示例时，“item2 undefined”会提醒三次！ 这是因为就像前面的例子一样，buildList的局部变量只有一个闭包。 当在fnlist [j]（）上调用匿名函数时; 它们都使用相同的单个闭包，并且它们使用该闭包内的i和项的当前值（其中i具有值3，因为循环已完成，并且项具有值'item2'）。 注意，我们从0索引，因此项目的值为item2。 并且i ++将i增加到值3。 例6 此示例显示，闭包包含在退出前在外部函数中声明的任何局部变量。 注意，变量alice实际上是在匿名函数之后声明的。 匿名函数首先声明; 并且当调用该函数时，它可以访问alice变量，因为alice在同一范围内（JavaScript变量提升）。 另外sayAlice（）（）只是直接调用从sayAlice（）返回的函数引用 - 它完全与以前做过的相同，但没有临时变量。 function sayAlice() { var say = function() { console.log(alice); } // Local variable that ends up within closure var alice = 'Hello Alice'; return say; } sayAlice()();// logs \"Hello Alice\" Tricky：还要注意，say变量也在闭包内，并且可以被可能被声明的任何其他函数访问sayAlice()，或者它可以在内部函数内被递归地访问。 例7 最后一个例子显示每个调用为局部变量创建一个单独的闭包。 每个函数声明没有单个闭包。 每个函数的调用都有一个闭包。 function newClosure(someNum, someRef) { // Local variables that end up within closure var num = someNum; var anArray = [1,2,3]; var ref = someRef; return function(x) { num += x; anArray.push(num); console.log('num: ' + num + '; anArray: ' + anArray.toString() + '; ref.someVar: ' + ref.someVar + ';'); } } obj = {someVar: 4}; fn1 = newClosure(4, obj); fn2 = newClosure(5, obj); fn1(1); // num: 5; anArray: 1,2,3,5; ref.someVar: 4; fn2(1); // num: 6; anArray: 1,2,3,6; ref.someVar: 4; obj.someVar++; fn1(2); // num: 7; anArray: 1,2,3,5,7; ref.someVar: 5; fn2(2); // num: 8; anArray: 1,2,3,6,8; ref.someVar: 5; 概要 如果一切似乎完全不清楚，那么最好的办法是玩的例子。阅读解释比理解示例困难得多。我对闭包和堆栈框架等的解释在技术上是不正确的 - 它们是用于帮助理解的粗略简化。一旦基本的想法是grokked，你可以提取细节后。 总结: 1.当你function在另一个函数里面使用时，使用闭包。 2.每当在函数中使用eval（）时，都会使用闭包。 eval的文本可以引用函数的局部变量，在eval中甚至可以使用eval（'var foo = ...'）创建新的局部变量 3.当在函数中使用新的Function（...）（Function构造函数）时，它不会创建闭包。 （新函数不能引用外层函数的局部变量。） 4.JavaScript中的闭包就像保留所有局部变量的副本，就像函数退出时一样。 5.最好是认为闭包始终只创建一个函数的入口，局部变量将添加到闭包中。 6.每次调用具有闭包的函数时，都会保存一组新的局部变量（假定函数在其中包含函数声明，并且对该函数的引用要么返回，要么以某种方式保留外部引用 ）。 7.两个函数可能看起来像它们具有相同的源文本，但是具有完全不同的行为，因为它们的“隐藏”闭包。 我不认为JavaScript代码实际上可以找出一个函数引用是否有闭包。 8.如果你试图做任何动态源代码修改（例如：myFunction = Function（myFunction.toString（）。replace（/ Hello /，'Hola'））;），如果myFunction是一个闭包 当然，你永远不会想到在运行时做源代码字符串替换，但...）。 9.可以在函数内的函数声明中获得函数声明 - 你可以在多个级别获得闭包。 10.我认为通常闭包是函数和捕获的变量的术语。 注意，我在本文中不使用这个定义！ 11.我怀疑JavaScript中的闭包不同于通常在函数式语言中发现的闭包。 链接: 1.Douglas Crockford的模拟私有属性和一个对象的私有方法，使用闭包。 2.一个伟大的解释如何闭包可以导致内存泄漏在IE如果你不小心。 感谢 如果你刚刚学到了闭包（在这里或其他地方！），那么我有兴趣任何反馈从您的任何更改，你可能建议，可以使本文更清楚。 发送电子邮件至morrisjohns.com（morris_closure @）。 请注意，我不是JavaScript的上师 - 也不是关闭。 "},"JavaScript/principle/04.html":{"url":"JavaScript/principle/04.html","title":"匿名函数和闭包","keywords":"","body":"匿名函数和闭包 在计算机科学中，闭包是函数的非局部变量（自由变量）的引用环境。 包含自由变量的函数与为所有这些自由变量提供了变量绑定的环境一起,被称为闭包。 以下内容为学习笔记，来自李炎恢老师的课堂纪要。 1.匿名函数 普通函数 function box() { //函数名是box return 'Lee'; } 匿名函数 function () { //匿名函数，会报错 return 'Lee'; } 通过表达式自我执行 (function box() { //封装成表达式 alert('Lee'); })(); //()表示执行函数，并且传参 把匿名函数赋值给变量 var box = function () { //将匿名函数赋给变量 return 'Lee'; }; alert(box()); //调用方式和函数调用相似 函数里的匿名函数 function box () { return function () { //函数里的匿名函数，产生闭包 return 'Lee'; } } alert(box()()); //调用匿名函数 2.闭包 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在 一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量。 通过闭包可以返回局部变量 function box() { var user = 'Lee'; return function () { //通过匿名函数返回box()局部变量 return user; }; } alert(box()()); //通过box()()来直接调用匿名函数返回值 var b = box(); alert(b()); //另一种调用匿名函数返回值 使用闭包有一个优点，也是它的缺点：就是可以把局部变量驻留在内存中，可以避免使 用全局变量。(全局变量污染导致应用程序不可预测性，每个模块都可调用必将引来灾难， 所以推荐使用私有的，封装的局部变量)。 通过全局变量来累加 var age = 100; //全局变量 function box() { age ++; //模块级可以调用全局变量，进行累加 } box(); //执行函数，累加了 alert(age); //输出全局变量 //通过局部变量无法实现累加 function box() { var age = 100; age ++; //累加 return age; } alert(box()); //101 alert(box()); //101，无法实现，因为又被初始化了 通过闭包可以实现局部变量的累加 function box() { var age = 100; return function () { age ++; return age; } } var b = box(); //获得函数 alert(b()); //调用匿名函数 alert(b()); //第二次调用匿名函数，实现累加 循环里包含匿名函数 function box() { var arr = []; for (var i = 0; i 上面的例子输出的结果都是5，也就是循环后得到的最大的i 值。因为b[i]调用的是匿 名函数，匿名函数并没有自我执行，等到调用的时候，box()已执行完毕，i 早已变成5，所 以最终的结果就是5 个5。 循环里包含匿名函数-改1，自我执行匿名函数 function box() { var arr = []; for (var i = 0; i 改1 中，我们让匿名函数进行自我执行，导致最终返回给a[i]的是数组而不是函数了。 最终导致b[0]-b[4]中保留了0,1,2,3,4 的值。 循环里包含匿名函数-改2，匿名函数下再做个匿名函 function box() { var arr = []; for (var i = 0; i 改1 和改2 中，我们通过匿名函数自我执行，立即把结果赋值给a[i]。每一个i，是调 用方通过按值传递的，所以最终返回的都是指定的递增的i。而不是box()函数里的i。 关于this 对象 在闭包中使用this 对象也可能会导致一些问题，this 对象是在运行时基于函数的执行环 境绑定的，如果this 在全局范围就是window，如果在对象内部就指向这个对象。而闭包却 在运行时指向window 的，因为闭包并不属于这个对象的属性或方法。 var user = 'The Window'; var obj = { user : 'The Object', getUserFunction : function () { return function () { //闭包不属于obj，里面的this 指向window return this.user; }; } }; alert(obj.getUserFunction()()); //The window //可以强制指向某个对象 alert(obj.getUserFunction().call(obj)); //The Object //也可以从上一个作用域中得到对象 getUserFunction : function () { var that = this; //从对象的方法里得对象 return function () { return that.user; }; } 内存泄漏 由于IE 的JScript 对象和DOM 对象使用不同的垃圾收集方式，因此闭包在IE 中会导致 一些问题。就是内存泄漏的问题，也就是无法销毁驻留在内存中的元素。以下代码有两个知 识点还没有学习到，一个是DOM，一个是事件。 function box() { var oDiv = document.getElementById('oDiv'); //oDiv 用完之后一直驻留在内存 oDiv.onclick = function () { alert(oDiv.innerHTML); //这里用oDiv 导致内存泄漏 }; } box(); 那么在最后应该将oDiv 解除引用来避免内存泄漏。 function box() { var oDiv = document.getElementById('oDiv'); var text = oDiv.innerHTML; oDiv.onclick = function () { alert(text); }; oDiv = null; //解除引用 } PS：如果并没有使用解除引用，那么需要等到浏览器关闭才得以释放。 模仿块级作用域 JavaScript 没有块级作用域的概念。 function box(count) { for (var i=0; i 以上两个例子，说明JavaScript 没有块级语句的作用域，if () {} for () {}等没有作用域， 如果有，出了这个范围i 就应该被销毁了。就算重新声明同一个变量也不会改变它的值。 JavaScript 不会提醒你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声 明视而不见(如果初始化了，当然还会执行的)。使用模仿块级作用域可避免这个问题。 模仿块级作用域(私有作用域) (function () { //这里是块级作用域 })(); //使用块级作用域(私有作用域)改写 function box(count) { (function () { for (var i = 0; i 使用了块级作用域(私有作用域)后，匿名函数中定义的任何变量，都会在执行结束时被 销毁。这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的 变量和函数。一般来说，我们都应该尽可能少向全局作用域中添加变量和函数。在大型项目 中，多人开发的时候，过多的全局变量和函数很容易导致命名冲突，引起灾难性的后果。如 果采用块级作用域(私有作用域)，每个开发者既可以使用自己的变量，又不必担心搞乱全局 作用域。 (function () { var box = [1,2,3,4]; alert(box); //box 出来就不认识了 })(); 在全局作用域中使用块级作用域可以减少闭包占用的内存问题，因为没有指向匿名函数 的引用。只要函数执行完毕，就可以立即销毁其作用域链了。 私有变量 JavaScript 没有私有属性的概念；所有的对象属性都是公有的。不过，却有一个私有变 量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问 这些变量。 function box() { var age = 100; //私有变量，外部无法访问 } 而通过函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而 利用这一点，可以创建用于访问私有变量的公有方法。 function Box() { var age = 100; //私有变量 function run() { //私有函数 return '运行中...'; } this.get = function () { //对外公共的特权方法 return age + run(); }; } var box = new Box(); alert(box.get()); 可以通过构造方法传参来访问私有变量 function Person(value) { var user = value; //这句其实可以省略 this.getUser = function () { return user; }; this.setUser = function (value) { user = value; }; } 但是对象的方法，在多次调用的时候，会多次创建。可以使用静态私有变量来避免这个 问题。 静态私有变量 通过块级作用域(私有作用域)中定义私有变量或函数，同样可以创建对外公共的特权方 法。 (function () { var age = 100; function run() { return '运行中...'; } Box = function () {}; //构造方法 Box.prototype.go = function () { //原型方法 return age + run(); }; })(); var box = new Box(); alert(box.go()); 上面的对象声明，采用的是Box = function () {} 而不是function Box() {} 因为如果用后 面这种，就变成私有函数了，无法在全局访问到了，所以使用了前面这种。 (function () { var user = ''; Person = function (value) { user = value; }; Person.prototype.getUser = function () { return user; }; Person.prototype.setUser = function (value) { user = value; } })(); 使用了prototype 导致方法共享了，而user 也就变成静态属性了。(所谓静态属性，即共 享于不同对象中的属性)。 模块模式 之前采用的都是构造函数的方式来创建私有变量和特权方法。那么对象字面量方式就采 用模块模式来创建。 var box = { //字面量对象，也是单例对象 age : 100, //这是公有属性，将要改成私有 run : function () { //这时公有函数，将要改成私有 return '运行中...'; }; }; 私有化变量和函数 var box = function () { var age = 100; function run() { return '运行中...'; } return { //直接返回对象 go : function () { return age + run(); } }; }(); 上面的直接返回对象的例子，也可以这么写 var box = function () { var age = 100; function run() { return '运行中...'; } var obj = { //创建字面量对象 go : function () { return age + run(); } }; return obj; //返回这个对象 }(); 字面量的对象声明，其实在设计模式中可以看作是一种单例模式，所谓单例模式，就是 永远保持对象的一个实例。 增强的模块模式，这种模式适合返回自定义对象，也就是构造函数。 function Desk() {}; var box = function () { var age = 100; function run() { return '运行中...'; } var desk = new Desk(); //可以实例化特定的对象 desk.go = function () { return age + run(); }; return desk; }(); alert(box.go()); "},"JavaScript/principle/05.html":{"url":"JavaScript/principle/05.html","title":"instanceof运算符","keywords":"","body":"instanceof运算符 原文 语法 object instanceof constructor 参数 object 要检测的对象. constructor 某个构造函数 描述 instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 // 定义构造函数 function C(){} function D(){} var o = new C(); // true，因为 Object.getPrototypeOf(o) === C.prototype o instanceof C; // false，因为 D.prototype不在o的原型链上 o instanceof D; o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true C.prototype instanceof Object // true,同上 C.prototype = {}; var o2 = new C(); o2 instanceof C; // true o instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上. D.prototype = new C(); // 继承 var o3 = new D(); o3 instanceof D; // true o3 instanceof C; // true 需要注意的是，如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的proto魔法属性，是可以实现的。比如执行obj.proto = {}之后，obj instanceof Foo就会返回false了。 instanceof和多全局对象(多个frame或多个window之间的交互) 在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回false，因为 Array.prototype !== window.frames[0].Array.prototype，因此你必须使用 Array.isArray(myObj) 或者 Object.prototype.toString.call(myObj) === \"[object Array]\"来判断myObj是否是数组。 例子 例子: 表明String对象和Date对象都属于Object类型 下面的代码使用了instanceof来证明：String和Date对象同时也属于Object类型。 var simpleStr = \"This is a simple string\"; var myString = new String(); var newStr = new String(\"String created with constructor\"); var myDate = new Date(); var myObj = {}; simpleStr instanceof String; // returns false, 检查原型链会找到 undefined myString instanceof String; // returns true newStr instanceof String; // returns true myString instanceof Object; // returns true myObj instanceof Object; // returns true, despite an undefined prototype ({}) instanceof Object; // returns true, 同上 myString instanceof Date; // returns false myDate instanceof Date; // returns true myDate instanceof Object; // returns true myDate instanceof String; // returns false 演示mycar属于Car类型的同时又属于Object类型 下面的代码创建了一个类型Car，以及该类型的对象实例mycar. instanceof运算符表明了这个mycar对象既属于Car类型，又属于Object类型。 function Car(make, model, year) { this.make = make; this.model = model; this.year = year; } var mycar = new Car(\"Honda\", \"Accord\", 1998); var a = mycar instanceof Car; // 返回 true var b = mycar instanceof Object; // 返回 true instanceof运算符在数组中的使用 确定一个对象在全局中是否为数组 var colors=['aa','bb','cc'];//创建包含三个字符串的数组 if (colors instanceof Array){ alert(1) }else { alert(0) } //最后输出 1，说明该对象为数组 "},"JavaScript/principle/06.html":{"url":"JavaScript/principle/06.html","title":"JavaScript事件流","keywords":"","body":"JavaScript事件流 定义 申明：本文仅限私人学习之用---- 原文； 下图展示了完整的js事件流 捕获阶段：Document==>ElementHtml==>ElementBody==>ElementDiv 冒泡阶段：ElementDiv==>ElementBody==>ElementHtml==>Document 分析 捕获阶段： document对象首先接收到click事件，然后事件沿DOM树依次向下，一直传播到事件的实际目标。 冒泡阶段： IE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（ 文档）。 事件处理程序 html事件处理程序 事件对象： event:不是自己定义的，是給元素綁定事件之后，自动生成的局部变量，表示事件对象。 this:在函數內部，等于事件的目标元素；在函數內部可以像访问局部变量一样访问document及该元素本身的成员。 //如果当前元素是一個表单的輸入元素，则作用域中还会包含访问表单元素（父元素）的入口 (function(){ with(document){ with(this.from){ //元素属性值 } } })() 缺点： 1.时差问题，用戶可能会在HTML元素一出現在页面上时，就触发相应事件， 但当时该事件有可能不具备执行条件。 2.这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。 不同JavaScript引擎遵循的标识符解析规则略有差异， 很可能会在访问非限定对象成员时出错。(高耦合) DOM0级事件处理程序 通过js指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性 //创建 var btn = document.getElementById(\"myBtn\"); btn.onclick=function(){ alert(\"Clicked\"); } //删除 btn.onclick=null; DOM2级事件处理程序 addEventListener() 为指定事件添加处理程序 // 下面这段程序中因为添加了false，所以该事件会在冒泡阶段被触发 var btn=document.getElementById('myBtn'); btn.addEventListener(\"click\",function(){ alert(\"this.id\"); },false); // 使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。 // 这两个事件处理程序会按照添加它们的顺序触发，因此首先会显示元素的ID，其次会显示\" Hello world!\" 消息。 var btn=document.getElementById(\"myBtn\"); btn.addEventListener(\"click\",function(){ alert(\"this.id\") },false); btn.addEventListener(\"click\",function(){ alert(\"Hello World！\") },false); removeEventListener() 删除事件处理程序 // 下面这个函数，虽然看起来合乎逻辑， // 但是removeEventListener清除的程序与addEventListener绑定的事件不是同一个 var btn=document.getElementById(\"myBtn\"); btn.addEventListener(\"click\",function(){ alert(\"Hello World！\") },false); btn.removeEventListener(\"click\",function(){ alert(\"Hello World!\"); }) // 我们在这里用另一个例子来表现,这个例子中绑定事件程序与删除事件程序使用了相同的函数 var btn=document.getElementById(\"myBtn\"); var handler = function () { alert(this.id); } btn.addEventListener(\"click\",handler,false); btn.removeEventListener(\"click\",handler,false); 建议 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。 IE事件处理程序 IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。 attachEvent() /* 下面这个例子中 事件绑定 时 ,第一个参数用的是 onclick， IE使用attachEvent()与使用DOM0方法的主要区别在于处理程序的作用域。*/ var btn=document.getElementById(\"MyBtn\"); btn.attachEvent(\"onclick\",function(){ alert(\"Clicked\"); }) /* 在DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行； 在使用attachEvent()方法的情况下，事件处理程序会在 全局作用域中运行， 因此this等于windows。 */ var btn =document.getElementById(\"myBtn\"); btn.attachEvent(\"onclick\",function(){ alert(this===window);//true }) // 添加多个元素的方法 var btn = document.getElementById(\"myBtn\"); var handler=function (){ alert(\"Hello World!\") } var hello=function (){ alert(\"hello\"); } btn.attachEvent(\"onclick\",handler); btn.attachEvent(\"onclick\",hello); // 执行顺序:多事件绑定，执行顺序是以倒序的方式执行的。 // hello // Hello World! detachEvent() // 移除attachEvent添加的事件处理程序程序 var btn = document.getElementById(\"myBtn\"); var handler = function () { alert('Clicked'); } btn.attachEvent(\"onclick\",handler); btn.detachEvent(\"onclick\",handler); 跨浏览器的事件处理程序 addHandler()|removeHandler() 这2个方法属于一个名叫EventUtil的对象 参数：要操作的元素 | 事件名称 | 事件处理接受程序 /* 解析：首先判断是否存在DOM2级方法，如果存在==>传入事件类型， 事件处理程序函数，和第三个参数方法false（表示冒泡阶段）， 如果存在的是IE的方法，就采用第二种方法，为了兼容IE8及跟早的版本， 此时的时间类型必须加上\"on\"前缀。 最后一种是DOm0级方法(现代浏览器，一般不会执行这里的代码)， 使用方括号语法将属性名指定为事件处理程序或者将属性设置为null；*/ var EventUtil={ addHandler:function(element,type,handler){ if(element.addEventListener){ element.addEventListener(type,handler,false); }else if(element.attachEvent){ element.attachEvent(\"on\" + type,handler); }else { element[\"on\" + type] = handler; } }, removeHandler:function(element,type,handler){ if(element.removeEventListener){ element.removeEventListener(element,type,false); }else if(element.detachEvent){ element.detachEvent(\"on\"+type,handler); }else{ element[\"on\"+type]=null; } } } // 实例：使用EventUtil对象==>绑定click事件并删除click事件 // 分析：由于addHandler和removeHandler没有考虑到所有浏览器的问题， // 例如IE浏览器中的作用域的问题，所以我们往往只用作添加处理程序或者移除处理程序。 //提示：只DoM0级的浏览器已经不多了，所以需要注意的问题不是很多 var btn = document.getElementById(\"myBtn\"); var handler = function (){ alert(\"你好！\"); } EventUtil.addHandler(btn,\"click\",handler); EventUtil.removeHandler(btn,\"click\",handler); "},"JavaScript/cases/":{"url":"JavaScript/cases/","title":"案例解析","keywords":"","body":"案例收集 "},"JavaScript/cases/0.html":{"url":"JavaScript/cases/0.html","title":"动态替换图片","keywords":"","body":"动态替换图片 目的： 在制作个人网站的时候，我需要在header里面加入各大社交网站的直链，可以让更多人，找到我，提供他们的想法。并且去实现那个想法。 展现方式： 是以一种点击图标的的形式，展示不同社交网站的二维码或者是链接。在开发过程中遇到很多有意思的坑，想分享给大家，希望可以给看到本文的小伙伴提供点帮助。 使用技巧 由于在一开始，我们就用了多个程序来进行区分不同事件点击之后，显示不同的图片的功能。但是在一段时间之后发现这样子的代码谈不上什么有价值的，所以我重新花了点时间，把代码重新架构了一番。清理了冗余代码，同时也把程序优化了。 优化之后的程序只要将植入代码，就可以实现简单的点击不同按钮,相同位置展示不同图片功能。 项目结构： ├──index // 示例 index │ ├──js │ │ └──index.js │ ├──css │ │ └──index.js index.html详解 首先页面header排版，设置具体结构 ├── div // 示例 header │ ├── div │ │ └── img │ │ └── img │ │ └── img 在每个img中添加onclick=\"hImage()\"属性，并给每个\"hImage()\"中加入\"1-3\"值；设置这个值，是为了在index.js的hImage()函数中做出对应的判断。 模态框 ├── div // 示例 模态框 │ ├── div │ │ └── div │ │ └── img │ │ └── h1 第一层div设置模态框显示之后的透明色背景。 第二层div主要是做模态框显示之后的内容的框架 第二层div下面的div是关闭模态框按钮。里面加入 onclick=\"hShow()\" 函数，该函数负责关闭模态框 × 第二层div下面的 img 则是展示不同图标点击之后，显示的二维码 第二层div下面的 h1 则是展示不同图标点击之后，显示的提示信息 这里的模态框设置 使用position中的fixed，来设置模态框的位置与样式。同 × index.js详解 var hModule = document.getElementsByClassName('h-module');//获取模态框中的关闭按钮属性 var hhtImg = document.getElementById(\"hhtImg\");//设置模态框不同位置按钮点击之后展示的属性图片属性 var hText=document.getElementById(\"hText\");//设置模态框显示之后的提示信息 /*hImage函数 * 由于图片只有一张，所以同时设置title属性以示区分 * 通过 switch语句判断点击不同按钮， * 在模态框展示不同的图片。 */ function hImage(e) { console.log(); switch (e) { case 1: //hhtImg.src为设置需要展示的图片的地址 hhtImg.src = \"http://oigzh9iic.bkt.clouddn.com/%E4%BA%AB%E6%9C%88%E4%BC%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg\"; hhtImg.title = \"这里是\" + e;//此处设置鼠标悬浮于图片时显示的文字 hText.innerHTML=\"这里是二维码\" + e;//此出设置模态框显示之后，展示提示文字的内容 break; case 2: hhtImg.src = \"http://oigzh9iic.bkt.clouddn.com/%E4%BA%AB%E6%9C%88%E4%BC%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg\"; hhtImg.title = \"这里是\" + e; hText.innerHTML=\"这里是二维码\" + e; break; case 3: hhtImg.src = \"http://oigzh9iic.bkt.clouddn.com/%E4%BA%AB%E6%9C%88%E4%BC%9A%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg\"; hhtImg.title = \"这里是\" + e; hText.innerHTML=\"这里是二维码\" + e; break; } hModule[0].style.display = \"block\"; } /*hShow函数 * 功能：关闭模态框； * 由于原生js中，获取参数的值 * 之后，其属性为数组形式； * 需要设置下标，再去设置style属性， * 或者是其他属性 * */ function hShow() { hModule[0].style.display = \"none\"; } "},"JavaScript/cases/01.html":{"url":"JavaScript/cases/01.html","title":"原生Ajax学习","keywords":"","body":"原生Ajax学习 示例 这里先展示一个比较复杂的应用写法，原理什么的看下面介绍。 注意，本例是学习笔记，学习地址 源码 document.getElementById(\"save\").onclick = function() { var request = new XMLHttpRequest(); request.open(\"POST\", \"server.php\"); var data = \"name=\" + document.getElementById(\"staffName\").value + \"&number=\" + document.getElementById(\"staffNumber\").value + \"&sex=\" + document.getElementById(\"staffSex\").value + \"&job=\" + document.getElementById(\"staffJob\").value; request.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); request.send(data); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { document.getElementById(\"createResult\").innerHTML = request.responseText; } else { alert(\"发生错误：\" + request.status); } } } } Ajax 其实原理很简单的。就是调用 XMLHttpRequest 对象来实现前端与后台的数据通信！ 第一步：实例化 XMLHttpRequest 对象 var request = new XMLHttpRequest(); 第二步：调用 open() 方法 open(Method[数据传输方法: POST | GET ], URL , async[true（异步）| false（同步）] ); request.open(\"GET\", \"server.php?number=\" + document.getElementById(\"keyword\").value); 第三步：调用 setRequestHeader 这里已经有人把 setRequestHeader 内容很详细的介绍一遍了，这里就不做太多的解释。传送门 request.open(\"GET\", \"server.php?number=\" + document.getElementById(\"keyword\").value); 第四步：调用 send() 方法 send方法接受一个参数，作为请求主体发送的数据。 注意:如果没有参数，则必须填写 null request.send(参数|null) 由于send的请求是同步的，请求得到服务器响应之后。响应的数据会自动填充XHR对象的属性 console.log(request.responseText);//响应主体被返回的文本 console.log(request.responseXML);//与 responseText 以字符串返回 HTTP 响应不同，responseXML 以 XML 返回响应。ResponseXML 属性返回 XML 文档对象，可使用 W3C DOM 节点树的方法和属性来检查和解析该对象。 request.status Ajax status和statusText状态对照表 0：未初始化。尚未调用open()方法。 1：启动。已调用open()方法,但尚未调用send()方法。 2：发生。已调用send()方法，但尚未接收到响应。 3：接受。已经接收到部分响应数据。 4：完成。已经接收到响应数据，并且可以在客户端使用。 console.log(request.status);//响应的HTTP状态 console.log(request.statusText);//HTTP状态的说明 第五步：调用 onreadystatechange 事件处理程序 request.onreadystatechange     当请求被发送到服务器时，我们需要执行一些基于响应的任务。     每当 readyState 改变时，就会触发 onreadystatechange 事件。     readyState 属性存有 XMLHttpRequest 的状态信息。 如下所示：我们通过if语句判断 request.readyState 的响应数据，进行数据处理。 request.onreadystatechange = function () { if (request.readyState === 4) { console.log(request.readyState); if (request.status === 200) { document.getElementById(\"createResult\").innerHTML = request.responseText; } else { alert(\"发生错误：\" + request.status); } } } "},"JavaScript/cases/02.html":{"url":"JavaScript/cases/02.html","title":"React/React Native 的ES5 ES6写法对照表","keywords":"","body":"React/React Native 的ES5 ES6写法对照表 来源： React on ES6+React/React Native 的ES5 ES6写法对照表 class定义语法 值得注意的是，我们已经删除了两个括号和一个后缀分号，而对于每个声明的方法，我们都省略了一个冒号，一个function关键字和一个逗号。 class Photo extends React.Component { render() { return } } // The ES5 way var Photo = React.createClass({ handleDoubleTap: function(e) { ... } render: function() { ... } }) //ThE ES6 way class Photo extends React.Component { handleDoubleTap(e) { ... } render() { ... } } 生命周期方法 所有的生命周期方法，但可以定义为使用新的类语法期望的。该课程constructor现在承担以前填写的角色componentWillMount： // es5 var EmbedModal = React.createClass({ componentWillMount: function() { ... } }) // es6 class EmbedModal extends React.createClass ( construtor(props) { super(props); // Operations usually carried out in componentWillMount go here } ) 属性初始化 ES7属性初始化器在类的构造函数中运行，其中this指的是正在构建的类的实例，所以初始状态仍然可以依赖于this.props。值得注意的是，我们不再需要根据吸气功能定义道具默认值和初始状态对象。 // es5 var Video = React.createClass({ getDefaultProps: function() { return { autoPlay: flase, maxLoops: 10, }; }, getInitalState: function() { return { loopsRemaining: this.props.maxloops, }; }, propsTypes: { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired }, }); // es6 class Video extends React.Component { static defaultProps = { autoPlay: false, maxloops: 10 } static propsTypes = { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.propsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired } state = { loopsRemaining: this.props.maxloops, } } 箭头函数说明 该React.createClass方法用于对组件的实例方法执行一些额外的绑定工作，以确保其中的this关键字将引用该组件的实例。 // 自动绑定React.createClass var PostInfo = React.createClass({ handleOptionsButtonClick: function(e) { // 这里，'this' 是指组件实例。 this.setState({showOptionModal: true}); }, }); 由于我们React.createClass在使用ES6 +类语法定义组件时不涉及该方法，所以我们需要手动绑定实例方法，无论我们想要这种行为： // 手动绑定，无论你是否需要 class PostInfo extends React.Component { construtor(props) { super(props); // 手动将此方法绑定到组件实例中… this.handleOptionsButtonClick = this.handleOptionsButtonClick.bind(this); } handleOptionsButtonClick(e) { // …为了确保'this'指的是组件实例。 this.setState({showOptionsModal: true}); } } 幸运的是，通过组合两个ES6 +功能 - 箭头函数和属性初始值设置 - 选择加入到组件实例的绑定变得轻而易举： class PostInfo extends React.Component { handleOptionsButtonClick = (e) => { this.setState({showOptionsModal: true}); } } ES6箭头函数的主体具有与它们周围this的代码相同的词汇，这使得我们获得了期望的结果，因为ES7属性初始化器的作用域的方式。在罩下看，看看为什么这个工作。 动态属性名称和模板字符串 其中的增强对象文本包括分配给派生属性名称的能力。我们原本可以做这样的事情来设定一个状态： ```js var From = React.createClass({ onChange: function(inputName, e) { var stateToSet = {}; stateToSet[inputName + 'Value'] = e.targe.value; this.setState(stateToset); }, }); // 现在，我们有能力构建在运行时由JavaScript表达式决定其属性名称的对象。在这里，我们使用模板字符串来确定要设置的属性： class From extends React.Component { onChange(inpuntName, e){ this.setState({ [`$(inputName)value`]: e.targe.value, }); } } ## 解构和传播属性 >通常在组成组件时，我们可能希望将大部分父组件的道具传递给子组件，但并不是全部。将ES6 + 解构与JSX 传播属性相结合，无需仪式即可实现： ```js class AutoloadingPostsGrid extends React.Component { render() { const { className, ...others // 包含所有特性this.props除了类名 } = this.props; return ( Load more ); } } // 我们可以将JSX传播属性与常规属性结合起来，利用简单的优先级规则来实现覆盖和默认值。该元素将获得className“覆盖”，即使存在一个className财产this.props： ... // This element will regularly have the “base” unless there exists a property in to override it: ... 模块 // 引用 // es5 var React = require(\"react\"); var { Component, PropsTypes } = React; //引用react抽象组件 var ReactNative = require(\"react-native\"); var { Image, Text, } = ReactNative; // 引用具体的React Native组件 // es6 import写法更为标准 import React, { Component, PropsTypes, } from 'react'; import { imange， Text, } from 'react-native' 导出单个类 在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出 // es5 var MyComponent = React.createClass({ // 函数 }) // es6 export default class MyComponent extends Component{ // 函数 } // 引用 class // es5 var MyComponent = require(('./MyComponent')); // es6 import MyComponent from './MyComponent'; 定义组件 es5 在ES5里，通常通过React.createClass来定义一个组件类，像这样： var Photo = React.createClass({ render: function() { return ( ) } }) 在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样： class Photo extends React.Component { render() { return ( ); } } 给组件定义方法 给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。 // es5 var Photo = React.createClass({ componentWillMount: function() { // 函数 }, render: function() { return ( ); }, }); // es6 class Photo extends React.Component { componentWillMount() { // 函数 }, render() { return ( ); } } 定义组件的属性类型和默认属性 在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现 // es5 var video = React.createClass({ getDefaultProps: function() { return { autoPlay: false, maxloops: 10, }; }, PropsTypes: { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired, }, render: function() { return: function() { }; } }) 在ES6里，可以统一使用static成员来实现 //es6 class Video extends React.Component { static defaultProps = { autoPlay: flase, maxloops: 10, }; // 注意这里有分号 static propsTypes = { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired, }; // 注意这里有分号 render() { return ( ) } } 也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思： //es6 class Videlo extends React.Component { render() { return ( ); } } Video.defauleftProps = { autoPlay: false, maxloops: 10, }; Video.propsTypes = { autoPlay: React.PropsTypes.bool.isRequired, maxloops: React.PropsTypes.number.isRequired, posterFrameSrc: React.PropsTypes.string.isRequired, videoSrc: React.PropsTypes.string.isRequired, } // 注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。 初始化STATE // es5 var video = React.createClass({ getInitalState: function() { return { loopsRemaining: this.props.maxloops, }; } }) // ES6下，有两种写法： class Video extends React.Component { state = { loopsRemaining: this.props.maxloops, } } // 不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）： // es6 class Video extends React.Component { construtor(props){ super(props); this.state = { loopsRemaining: this.props.maxloops, } } } 把方法作为回调提供 很多习惯于ES6的用户反而不理解在ES5下可以这么做： var PostInfo = React.createClass({ handleOptionsButtonClick: function(e) { // Here,'this' refers to the component instance this.setState({showOptionModel: true}); }, render: function() { return ( {this.props.label} ) }, }); 在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用 // es6 class PostInfo extends React.Component { handleOptionsButtonClick(e){ this.setState({showOptionsModal: true}); } render() { return ( this.handleOptionsButtonClick(e)} > {this.props.label} ) }, } 箭头函数 箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=>之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。 // 箭头函数实例 ()=>1 v=>v+1 (a,b)=>a+b ()=>{ alert('foo'); } e=>{ if (e == 0){ return 0; } return 1000/e; } 需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用 // 错误的做法 class PaussMenu extends React.Component{ componentWillMount() { AppStateIOS.addEventListener('change', this.onAppPaused.bind(this)); } componentDidUnmount() { AppStateIOS.removeEventListener('change', this.onAppPaused.buid(this)); } onAppPaused(event){ } } // 正确的做法 class PaussMenu extends React.Component{ construtor(props) { super(props); this._OnAppPaused = this.onAppPaused.bind(this); } componentWillMount() { AppStateIOS.addEventListener('change', this._OnAppPaused); } componentDidUnmount() { AppStateIOS.removeEventListener('change', this_onAppPaused); } onAppPaused(event) { } } // 从这个帖子[这个帖子](http://www.tuicool.com/articles/Rj6RFnm)中我们还学习到一种新的做法： // 正确的做法 class PaussMenu extends React.createClass{ componentWillMount() { AppStateIOS.addEventListener('change', this.onAppPaused); } componentDidUnmount() { AppStateIOS.removeEventListener('change', this.onAppPaused); } onAppPaused = (event) => { // 把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this的指针 } } Mixins 在ES5下，我们经常使用minxin来为我们的类添加一些新的方法，譬如PureRenderMinxin ``` var PurRenderMixin = require('react-addins-pure-render-minxin'); React.createClass({ mixin: [PurRenderMixin], render: function() { return foo; } }) > 然而现在官方已经不再打算在ES6里继续推行Mixin，他们说：Mixins Are Dead. Long Live Composition。 尽管如果要继续使用mixin，还是有一些第三方的方案可以用，譬如这个方案 不过官方推荐，对于库编写者而言，应当尽快放弃Mixin的编写方式，文中提到Sebastian Markbåge的一段代码推荐了一种新的编码方式： //Enhance.js import { Component } from 'React' extends var Enhance = ComposedComponent => class extends Component { construtor() { this.state = {dtaa:null} } componentDidUnmount() { this.setState({ data: 'Hello' }); } render() { renturn } } // HigherOrderComponent.js import { Enhance } from \"./Enhance\"; class MyComponent { render() { if (!this.data) return Waiting...; return {this.data}; } } export defaule Enhance(MyComponent); // Enhance component //用一个“增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。 ## ES6+带来的其它好处 ### 解构&属性延展 > 结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签： class AutoloadingPostsGrid extends React.Component { render() { var { className, ...others, } = this.props; return ( Load more ); } } > 下面这种写法，则是传递所有属性的同时，用覆盖新的className值： ... > 这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值 ... ``` "},"JavaScript/cases/03.html":{"url":"JavaScript/cases/03.html","title":"战舰游戏","keywords":"","body":"战舰游戏 输入 * { margin: 0; padding: 0; } body{ background-color: black; } .continuar { margin: 0; /*width: 100%;*/ width: 650px; position: relative; height: 650px; background: url('../images/board.jpg') no-repeat; background-size: contain; /* background-color: rgba(37, 17, 17, 0.849); */ } table { margin: 0 auto; /*padding-top: 9%;*/ padding-top: 62px; } tr td { width: 60px; height: 60px; border: 0px solid rgb(21, 172, 16); } td.ship{ background: url('../images/ship.png') no-repeat; background-size: contain; background-position: center; } td.miss{ background: url('../images/miss.png') no-repeat; background-size: contain; background-position: center; } .enter{ position: absolute; right: 14%; bottom:0; display: flex; padding: 20px; } .enter input { height: 35px; color: #000000; background-color: rgb(159, 255, 48); display: block; float: left; border:0; } .enter .btn{ height: 25px; float: left; padding: 0 5px; cursor:pointer; font-size: 12px; color: aliceblue; margin-left: 5px; line-height: 25px; user-select: none; text-align: center; background-color: #41510d; border:5px solid #46e234; } window.onload = function () { let btnEnter = document.getElementById('btnEnter'); let coordinate = document.getElementById('coordinate'); // 给节点添加点击事件 btnEnter.onclick = btn; coordinate.onkeypress = key; function key(e) { // 监听`enter`键是否被点击 if (e.charCode === 13) { btn() } } // 转化坐标 let digital = {'A': 0, 'B': 7, 'C': 14, 'D': 21, 'E': 28, 'F': 35, 'G': 42}; // 使用随机数,初始化战舰位置 let ships = {0: Math.floor(Math.random() * 48), 1: Math.floor(Math.random() * 48), 2: Math.floor(Math.random() * 48)}; console.log(ships); // 获取所有的`td` function btn() { console.log(coordinate.value); let patt1 = new RegExp(/^[a-g][0-6]/i); if (patt1.test(coordinate.value)) { // 截取字符串中的首位,将其转化为大写字母 let coordinateText = coordinate.value[0].toUpperCase(); // 玩家输入的战舰坐标 let coordinateNumber = Number.parseInt(digital[coordinateText]) + Number.parseInt(coordinate.value[1]); // 获取所有名为 `td` 的节点 let tds = document.getElementsByTagName('td'); // 判断玩家输入的坐标上,是否有战舰存在,如果有的话,就击沉战舰 if (ships[0] === coordinateNumber || ships[1] === coordinateNumber || ships[2] === coordinateNumber) { // 击沉战舰 tds[coordinateNumber].setAttribute('class', 'ship'); } else { // 没有击沉战舰 tds[coordinateNumber].setAttribute('class', 'miss'); } } else { alert('请输入正确的坐标;\\n如: A6!') } } }; "},"JavaScript/cases/04.html":{"url":"JavaScript/cases/04.html","title":"正则截取指定字符串","keywords":"","body":"正则截取指定字符串 参考文章 正则截取指定字符串 let str='{\"asd\":\\\\1234\\\\1234\\\\1234\\\\1234,\"true\"}, {\"sada\":\\\\1111\\\\1234\\\\1234\\\\4444,\"true\"}'; let substr = str.match(/\"sada\":(\\S*),\"true\"/); console.log(substr[1]); // \\\\1111\\\\1234\\\\1234\\\\4444 "},"JavaScript/cases/05.html":{"url":"JavaScript/cases/05.html","title":"常用功能收集","keywords":"","body":"常用功能收集 浏览器基本信息判断 /* * 智能机浏览器版本信息: * */ var browser = { versions: function () { var u = navigator.userAgent, app = navigator.appVersion; console.log(u); return {//移动终端浏览器版本信息 trident: u.indexOf('Trident') > -1, //IE内核 presto: u.indexOf('Presto') > -1, //opera内核 webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/Mobile/g), //去掉浏览器内核判断 // mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') > -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 }; }(), language: (navigator.browserLanguage || navigator.language).toLowerCase() } document.writeln(\"语言版本: \" + browser.language); document.writeln(\" 是否为移动终端: \" + browser.versions.mobile); document.writeln(\" 是否为webKit: \" + browser.versions.webKit); document.writeln(\" ios终端: \" + browser.versions.ios); document.writeln(\" android终端: \" + browser.versions.android); document.writeln(\" 是否为iPhone: \" + browser.versions.iPhone); document.writeln(\" 是否iPad: \" + browser.versions.iPad); document.writeln(navigator.userAgent); JavaScript|jQuery判断元素即将出现在文档可视区域或文档可视区域的顶部 /* JavaScript判断元素即将出现在文档可视区域或离开文档可视区域. 一、判断元素是否处于可视文档区域顶部 判断条件:DOMTop.offsetTop + clientHeight - 10 导航条动画，设定 function navAnimation() { let DOMTop = document.getElementById('nav'), // 获取导航对象 clientHeight = document.documentElement.clientHeight, // 获取窗口可视区域高度 tru = true, // 是否替换类名的依据 clientHeightScrollTop = clientHeight + DOMTop.offsetTop + DOMTop.clientHeight; // 是否替换类名的依据 // 监听文档滚动条事件，绑定动画 document.addEventListener('scroll', function () { let scrollTop = null; if (document.body.scrollTop !== 0) { scrollTop = document.body.scrollTop } else { scrollTop = document.documentElement.scrollTop } if (tru && clientHeightScrollTop clientHeight + scrollTop) { DOMTop.setAttribute('class', 'page-nav'); tru = true } }, false); } 锚链接跳转过渡 /* # 锚链接跳转过度 条件： 1.目标位置 & 滚动条位置 距离过近 2.目标位置 > 滚动条位置 3.目标位置 21) { let scrollInterval = setInterval(function () { if (s 文章标题的动画 function animateIn() { let animateIn = document.querySelectorAll('.container .title strong'); // console.log(animateIn.getAttribute('class')) // console.log(animateIn) let that = null; for (let i = 0; i "},"other/faq.html":{"url":"other/faq.html","title":"FAQ","keywords":"","body":"F.A.Q "},"other/examples.html":{"url":"other/examples.html","title":"Examples","keywords":"","body":"Examples "},"JavaScript/":{"url":"JavaScript/","title":"前言","keywords":"","body":""},"Basic/Ajax/":{"url":"Basic/Ajax/","title":"Ajax","keywords":"","body":"Ajax "},"Basic/Ajax/get请求传参长度的误区.html":{"url":"Basic/Ajax/get请求传参长度的误区.html","title":"get请求传参长度的误区","keywords":"","body":"get请求传参长度的误区 第一点:get|post请求,都没有长度的限制,get求限制来自于浏览器与服务器 "},"Basic/Ajax/get|post的区别.html":{"url":"Basic/Ajax/get|post的区别.html","title":"get|post的区别","keywords":"","body":"get|post 的区别 知乎 RFC7231 里定义了 HTTP 方法的几个性质： 1.Safe - 安全         这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此 RFC 定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如上文说过的使用 GET 修改用户信息的情况。引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。 2.Idempotent - 幂等         幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照 RFC 规范，PUT，DELETE 和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到 POST 会给用户提示的原因：POST 语义不是幂等的，重复请求可能会带来意想不到的后果。 3.Cacheable - 可缓存性         顾名思义就是一个方法是否可以被缓存，此 RFC 里 GET，HEAD 和某些情况下的 POST 都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持 GET 和 HEAD。关于缓存的更多内容可以去看RFC7234。 总而言之: GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader 的约束）,GET 方法的报文主体没有任何语义。POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。为了针对其不可缓存性，有一系列的方法来进行优化，以后有机会再研究（FLAG 已经立起）。还是举一个通俗栗子吧，在微博这个场景里，GET 的语义会被用在「看看我的 Timeline 上最新的 20 条微博」这样的场景，而 POST 的语义会被用在「发微博、评论、点赞」这样的场景中。 作者：杨光 链接：https://www.zhihu.com/question/28586791/answer/145424285 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 w3school 解释 比较 GET 与 POST 下面的表格比较了两种 HTTP 方法：GET 和 POST。 说明 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不可收藏为书签 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 "},"Terminology/":{"url":"Terminology/","title":"网络","keywords":"","body":"Specification(技术规范) 维基百科的释义) implementation(实现方式) 维基百科的释义 "}}