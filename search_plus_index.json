{"./":{"url":"./","title":"关于本文档","keywords":"","body":"说明 本文档分为上下2部分内容基础和进阶;这2部分内容会进一步随内容的深入而展开.基本就这些了 "},"Terminology/":{"url":"Terminology/","title":"网络","keywords":"","body":"Specification(技术规范) 维基百科的释义) implementation(实现方式) 维基百科的释义 "},"Basic/Ajax/":{"url":"Basic/Ajax/","title":"Ajax","keywords":"","body":"Ajax 定义:用 JavaScript 执行异步网络请求 资料 code function success(text) { var textarea = document.getElementById('test-response-text'); textarea.value = text; } function fail(code) { var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code; } var request; // 新建XMLHttpRequest对象 if (window.XMLHttpRequest) { request = new XMLHttpRequest(); } else { request = new ActiveXObject('Microsoft.XMLHTTP'); } request.onreadystatechange = function() { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... } }; // 发送请求: request.open('GET', '/api/categories'); request.send(); alert('请求已发送，请等待响应...'); 通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 "},"Basic/Ajax/get|post的区别.html":{"url":"Basic/Ajax/get|post的区别.html","title":"get|post的区别","keywords":"","body":"get | post 的区别 知乎 RFC7231 里定义了 HTTP 方法的几个性质： 1.Safe - 安全         这里的「安全」和通常理解的「安全」意义不同，如果一个方法的语义在本质上是「只读」的，那么这个方法就是安全的。客户端向服务端的资源发起的请求如果使用了是安全的方法，就不应该引起服务端任何的状态变化，因此也是无害的。 此 RFC 定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，正如上文说过的使用 GET 修改用户信息的情况。引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。 2.Idempotent - 幂等         幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同。按照 RFC 规范，PUT，DELETE 和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到 POST 会给用户提示的原因：POST 语义不是幂等的，重复请求可能会带来意想不到的后果。 3.Cacheable - 可缓存性         顾名思义就是一个方法是否可以被缓存，此 RFC 里 GET，HEAD 和某些情况下的 POST 都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持 GET 和 HEAD。关于缓存的更多内容可以去看RFC7234。 总而言之: GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader 的约束）,GET 方法的报文主体没有任何语义。POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。为了针对其不可缓存性，有一系列的方法来进行优化，以后有机会再研究（FLAG 已经立起）。还是举一个通俗栗子吧，在微博这个场景里，GET 的语义会被用在「看看我的 Timeline 上最新的 20 条微博」这样的场景，而 POST 的语义会被用在「发微博、评论、点赞」这样的场景中。 作者：杨光 链接：https://www.zhihu.com/question/28586791/answer/145424285 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 w3school 解释 比较 GET 与 POST 下面的表格比较了两种 HTTP 方法：GET 和 POST。 说明 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不可收藏为书签 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 补充一个 get 和 post 在缓存方面的区别: 1.get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 2.post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。 "},"Basic/Ajax/get请求传参长度的误区.html":{"url":"Basic/Ajax/get请求传参长度的误区.html","title":"get请求传参长度的误区","keywords":"","body":"get请求传参长度的误区 第一点:get|post请求,都没有长度的限制,get求限制来自于浏览器与服务器 "},"Advanced/":{"url":"Advanced/","title":"前言","keywords":"","body":"进阶篇 "},"HTTP/http post传送文件详解.html":{"url":"HTTP/http post传送文件详解.html","title":"http post传送文件详解","keywords":"","body":"http post 传送文件详解(转载) 首先客户端链接 192.168.24.56 后, 应该发送如下 http 请求： POST/logsys/home/uploadIspeedLog!doDefault.html HTTP/1.1 Accept: text/plain, _/_ Accept-Language: zh-cn Host: 192.168.24.56 Content-Type:multipart/form-data; boundary=-----------------------------7db372eb000e2 User-Agent: WinHttpClient Content-Length: 3693 Connection: Keep-Alive -------------------------------7db372eb000e2 Content-Disposition: form-data; name=\"file\"; filename=\"kn.jpg\" Content-Type: image/jpeg (此处省略 jpeg 文件二进制数据...） -------------------------------7db372eb000e2-- 此内容必须一字不差，包括最后的回车，红色字体部分就是协议的头。给服务器上传数据时，并非协议头每个字段都得说明，其中，content-type是必须的，它包括一个类似标志性质的名为boundary的标志，它可以是随便输入的字符串。对后面的具体内容也是必须的。它用来分辨一段内容的开始。Content-Length: 3693 ，这里的 3693 是要上传文件的总长度。绿色字体部分就是需要上传的数据，可以是文本，也可以是图片等。数据内容前面需要有 Content-Disposition, Content-Type 以及 Content-Transfer-Encoding 等说明字段。最后的紫色部分就是协议的结尾了。 注意这一行： Content-Type: multipart/form-data; boundary=---------------------------7db372eb000e2 根据 rfc1867, multipart/form-data 是必须的. ---------------------------7db372eb000e2 是分隔符，分隔多个文件、表单项。其中 b372eb000e2是即时生成的一个数字，用以确保整个分隔符不会在文件或表单项的内容中出现。Form 每个部分用分隔符分割，分隔符之前必须加上\"--\"着两个字符(即--{boundary})才能被 http 协议认为是 Form 的分隔符，表示结束的话用在正确的分隔符后面添加\"--\"表示结束。 前面的 ---------------------------7d 是 IE 特有的标志,Mozila 为---------------------------71 每个分隔的数据的都可以用 Content-Type 来表示下面数据的类型，可以参考 rfc1341 (http://www.ietf.org/rfc/rfc1341.txt) 例如 ：Contect-Type:image/jpeg 表示下面的数据是 jpeg 文件数据 转载：http://www.cnblogs.com/liangbin/articles/2117288.html ******* HTTP 响应 在接收和解释请求消息后，服务器会返回一个 HTTP 响应消息。 与 HTTP 请求类似，HTTP 响应也是三个部分组成，分别是： 状态行、消息报头、响应正文。 状态行： 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。 格式: HTTP-Version Status-Code Reason-Phrase CRLF 例如: HTTP/1.1 200 OK \\r\\n 状态代码： 状态代码由 3 位数字组成，表示请求是否被理解或被满足。 状态描述： 状态描述给出了关于状态代码的简短的文字描述。 状态代码的第一个数字定义了响应的类别，后面两位没有具体的分类。 第一个数字有五种可能的取值： 1xx: 指示信息—表示请求已接收，继续处理。 2xx: 成功—表示请求已经被成功接收、理解、接受。 3xx: 重定向—要完成请求必须进行更进一步的操作。 4xx: 客户端错误—请求有语法错误或请求无法实现。 5xx: 服务器端错误—服务器未能实现合法的请求。 状态代码 状态描述 说明 200 OK 客户端请求成功 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthonzed 请求未经授权。这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的 URL。 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 HTTP消息 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行，消息报头(可选的)，空行(只有CTLF的行)，消息正文(可选的)组成。 对于请求消息，开始行就是请求行。 对于响应消息，开始行就是状态行。 消息报头 HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。 每一个报头域都是由(名字＋\":\"＋空格＋值)组成,消息报头域的名字是大小写无关的。 普通报头 在普通报头中，有少数报头域应用于所有的请求和响应消息，但并不用于被传输的实体，这些报头域只用于传输的消息。 常用的普通报头域：Cache-Control,Date,Connection,Pragma. 请求报头 请求报头允许客户端向服务器端传递该请求的附加信息以及客户端自身的信息。 常用的请求报头域： Accept Accept请求报头域用语指定客户端接受哪些类型的信息。例如：Accept: image/gif,表明客户端希望接受GIF图象格式的资源；Accept: text/html,表明客户端希望接受html文本 Accept-Charset Accept-Charset请求报头域用于指定客户端接受的字符集。例如：Accept-Charset: ios-8859-1,gb2312。如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Accept-Encoding Accept-Encoding请求报头域类似Accept，但是它是用于指定可接受的内容编码。例如：Accept-Encoding: gzip, deflate。如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可接受。 Accept-Language Accept-Language请求报头域类似于Accept,但是它是用于指定一种自然语言。例如：Accept-Language: zh-cn。如果请求消息中没有设置这个域，服务器假定客户端对各种语言都可接受。 Authorization Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401(未授权)，可以发送一个包含Authorization请求报头域的请求，要服务器对其进行验证。 Host Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常是从HTTP URL中提取出来的。例如:http://www.sunxin.org/index.html。浏览器发送的请求消息中，就会包含`Host`请求报头域，如下：Host: www.sunxin.org 后面没有跟端口号，表明使用的是缺省端口号80，如果端口号不是80，那么就要在主机名后面加上一个冒号(\":\"),然后接上端口号，例如： Host: www.sunxin.org:8080。 要注意的是，在发送HTTP请求的时候，这个报头域是必须的。User-Agent User-Agent允许客户端将它的操作系统浏览器和其他属性告诉服务器。我们上网登陆论坛的时候，往往看到些欢迎信息，其中列出了你的操作系统的名称和版本等等信息。原因是：服务器从User-Agent请求报头域中获取的这些信息，自己编写浏览器可以不用这个请求报头域。服务器就无法得知了。 响应报头 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头域： Location Location响应报头域用于重定向接受者到一个新的位置。例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务器端可以发回Location响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源。当我们在JSP中使用重定向语句的时候，服务器端向客户端发回的响应报头中，就会有Location响应报头域。下面是Location响应报头域的一个例子：Location:http://www.sunxin.org Server Server响应报头域包含了服务器用来处理请求的软件信息。它和User-Agent请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户端软件(浏览器)和操作系统的信息。下面是Server响应报头域的一个例子：Server: Apache-Coyote/1.1 WWW-Authenticate WWW-Authenticate响应报头域必须被包含在401(未授权的)响应消息中，这个报头域和前面讲到的Authorization请求报头域是相关的，当客户端收到401响应消息，就要决定是否请求服务器对其进行验证。如果要求服务器对其进行验证，就可以发送一个包含了Authorization报头域的请求，下面是WWW-Authenticate响应报头域的一个例子：WWW-Authenticate: Basic realm=\"Basic Auth Test!\" 从这个响应报头域，可以知道服务器端对我们所请求的资源采用的是基本验证机制。 实体报头 请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，大多数情况下，实体正文就是请求消息中的请求正文或者响应消息中的响应正文。但是在发送时，并不是说实体报头域和实体正文要在一起发送，例如：有些响应可以只包含实体报头域。实体就好象我们写的书信，在信中，我们可以写上标题，加上页号等，这部分就相当于是实体报头域，而我们所写的书信的内容，就相当于实体正文。前面说讲的普通报头、请求报头、响应报头我们可以看成是写在信封上的邮编、接收者，发送者等内容。 实体报头定义了关于实体正文(例如：有无实体正文)和请求所标识的资源的元信息。 所谓元信息，是指描述其他信息的信息。 常用的实体报头域： Content-Encoding Content-Encoding实体报头域被使用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用语记录文档的压缩方法，下面是它的一个例子：Content-Encoding: gzip。如果一个实体正文采用了编码方式存储，在使用之前就必须进行解码。 Content-Language Content-Language实体报头域描述了资源所用的自然语言。Content-Language允许用户遵照自身的首选语言来识别和区分实体。如果这个实体内容仅仅打算提供给丹麦的阅读者，那么可以按照如下的方式设置这个实体报头域：Content-Language: da。 如果没有指定Content-Language报头域，那么实体内容将提供给所以语言的阅读者。 Content-Length Content-Length实体报头域用于指明正文的长度，以字节方式存储的十进制数字来表示，也就是一个数字字符占一个字节，用其对应的ASCII码存储传输。 要注意的是：这个长度仅仅是表示实体正文的长度，没有包括实体报头的长度。 Content-Type Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。例如： Content-Type: text/html;charset=ISO-8859-1 Content-Type: text/html;charset=GB2312 Last-Modified Last-Modified实体报头域用于指示资源最后的修改日期及时间。 Expires Expires实体报头域给出响应过期的日期和时间。通常，代理服务器或浏览器会缓存一些页面。当用户再次访问这些页面时，直接从缓存中加载并显示给用户，这样缩短了响应的时间，减少服务器的负载。为了让代理服务器或浏览器在一段时间后更新页面，我们可以使用Expires实体报头域指定页面过期的时间。当用户又一次访问页面时，如果Expires报头域给出的日期和时间比Date普通报头域给出的日期和时间要早(或相同)，那么代理服务器或浏览器就不会再使用缓存的页面而是从服务器上请求更新的页面。不过要注意，即使页面过期了，也并不意味着服务器上的原始资源在此时间之前或之后发生了改变。 Expires实体报头域使用的日期和时间必须是RFC 1123中的日期格式，例如：Expires: Thu, 15 Sep 2005 16:00:00 GMT HTTP1.1的客户端和缓存必须将其他非法的日期格式(也包括0)看作已过期。例如，为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置它的值为0，如下(JSP)：response.setDateHeader(\"Expires\",0); 除掉注释的部分就是一个完整的包，向/user/tmpUpload.php上传了一个文件。 =========http头========== POST /user/tmpUpload.php HTTP/1.1 Content-Type: multipart/form-data; boundary=---------------------------7d53b9297030e Content-Length: 1017 -----------------------------7d53b9297030e Content-Disposition: form-data; name=\"upload\"; filename=\"C:\\Documents.and.Settings\\hwy\\桌面\\attachment\" Content-Type: p 111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 11111111111111111111111111111111111111111 111111111111111111111111111111111111 -----------------------------7d53b9297030e-- ===========结束============ 本文来自 xyz_1991 的 CSDN 博客 ，全文地址请点击：https://blog.csdn.net/xyz_1991/article/details/51320578?utm_source=copy "},"other/faq.html":{"url":"other/faq.html","title":"FAQ","keywords":"","body":"F.A.Q "},"other/examples.html":{"url":"other/examples.html","title":"Examples","keywords":"","body":"Examples "}}